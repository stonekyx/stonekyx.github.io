---
layout: post
title: "Details of framebuffer-drawing process in EGUI"
date: 2014-04-17 19:52:52 +0800
comments: true
categories: 
---

##多分辨率支持问题的解决

在一年前，EGUI是不能支持`1366*768`像素分辨率的。实际上，当时的组长要求在运行时通过内核参数将tty的分辨率设置为`1024*768`。当时的例会上有人说过正在研究怎么解决这个问题，但好像没有下文，所以后来我就自己尝试将它解决了。

实际上解决问题的那个commit是9ed112e，但由于当时git使用不熟，现在在`screen_set_pixel.c`里blame的话可能是比较难找到这个commit的，因为它被revert过两次。

正如commit message里所说，这个问题的原因是fb里每一行的长度（以字节为单位）并不等于`实际像素数*颜色深度位数/CHAR_BIT`。之前那种做法会导致每一行都有些数据被写到了fb里的未使用位置上，所以显示就错乱了。换句话说，实际上就是二维数组的第二维长度计算错误。

好在那么长的一个函数里，只有一处需要这个行宽，所以直接改成`global_fix_screen_info.line_length`即可。

##`screen_set_pixel`等函数的可复用性提升

这个不能说做得很好，因为只是将一个大函数拆成几个小部分，再加几个省去参数的形式而已。

这么做的目的是，在其他部分的开发中，发现`screen_set_pixel`只能往screen结构体里绘图实在是太可惜，因为有些时候没办法提供screen结构体（比如`screen_cpy_area`函数里），或者不需要重新检查边界（比如`engine_fill_polygon`里）。这种调用频繁的函数，能省下一点时间总是好的。

现在`screen_set_pixel`已经被拆分成很多种调用方式了，没办法一一说明。这里只介绍一下命名规则。

* **`_r`**: 不将绘制结果写到第一个参数给定的对象里，而是写到另外一个里。这样可以防止原始的屏幕数据被破坏，也省去了调用者备份原始数据的必要。
* **`_nocheck`**: 跳过边界检查。一般的调用中都会执行一个矩形边界检查，如果在工作区域外的话就不绘制。但如果调用者已经一次性把所有的像素都检查完了，这里就不用再重复。
* **`_raw`**: 将screen结构体替换成`void*`。当然这样的话就需要额外给定一些数据才行，包括screen的长度、宽度和色彩深度。

上面这三种可以进行必要的组合。实际上各个版本不过是在互相调用而已，最终核心的代码在`screen_set_pixel_raw_r_nocheck`里。
