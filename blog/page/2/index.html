
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>My Octopress Blog</title>
  <meta name="author" content="Your Name">

  
  <meta name="description" content="该页没有发布，如果你觉得可以发布到首页上去，请告诉我。另外，该网站禁止了搜索引擎的索引。 项目前段：Curry 任务目标 首页游戏。在现有基础上实现地图的背景，并设计完成行走任务之后的效果。
用户认证，将用户分成未认证、dev、pm、admin等几类。需要实现的内容包括后台的数据结构和前端界面。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://stonekyx.github.io/blog/page/2">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="My Octopress Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">My Octopress Blog</a></h1>
  
    <h2>A blogging framework for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:stonekyx.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/proj-prosp.html">毕设项目预期</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-02-28T03:37:00+08:00" pubdate data-updated="true">Feb 28<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>该页没有发布，如果你觉得可以发布到首页上去，请告诉我。另外，该网站禁止了搜索引擎的索引。</p>

<hr />

<h1>项目前段：Curry</h1>

<h2>任务目标</h2>

<ol>
<li>首页游戏。在现有基础上实现地图的背景，并设计完成行走任务之后的效果。</li>
<li>用户认证，将用户分成未认证、dev、pm、admin等几类。需要实现的内容包括后台的数据结构和前端界面。</li>
<li>对后台数据（即用户可以保存的数据）进行规定并实现。这一步不包括前端。</li>
<li>不同用户的视图和数据权限，即实现前端。设计数据添加、展示和修改（允许的话）的方式。可能有大量的js。</li>
<li>测试、排除bug。进一步的修正和补充在项目后段中通过实践来完成。</li>
</ol>


<h2>时间预期</h2>

<p>以下序号与上文对应。括号内为粗略日期，后面是预期完成度，最后还有的话是备注。这部分考虑毕设的截止日期为6月10日。<strong>注意：</strong>本文没有考虑开发人员临时离开学校的情况。</p>

<ol>
<li>3月初（3/10），95%</li>
<li>3月中后（3/20），90%</li>
<li>3月底（3/30），60%，可能会有不完整的设计，到下面一步中再完善。</li>
<li>4月底（4/25），70%~75%，可能有不完整的实现，到项目后段再完善。</li>
<li>4月末（4/30），90%（或未知，根据前面的实现程度，可能无法评估bug的数量）</li>
</ol>


<h2>理想化时间预期</h2>

<p>以下不考虑毕设截止时间，以最合适的开发状态和完成度优先。</p>

<ol>
<li>3月初（3/10），95%</li>
<li>3月中后（3/25），95%</li>
<li>3月底（3/30），60%，同上，可能有不完整设计。</li>
<li>5月初（5/10），90%~95%，有比较充足的时间完善前面的设计。</li>
<li>5月中后（5/20），90%。</li>
</ol>


<hr />

<h1>项目后段：Game</h1>

<h2>任务目标</h2>

<ol>
<li>完成游戏概念和玩法的设计，最好是用js或者sdl做出一个mockup。</li>
<li>实现角色移动。</li>
<li>实现背景。</li>
<li>实现游戏逻辑。</li>
<li>游戏逻辑的增强和补充、测试、排除bug。</li>
<li>附加目标：补充Curry的不足之处，利用多余时间完成。</li>
</ol>


<h2>时间预期</h2>

<p>时间预期与之前格式一致。</p>

<ol>
<li>5月初（5/3），85%。这一步时间较短，但正好放假，视情况可能会工作得比较累。设计工作可能需要在开始之前就完成一部分。</li>
<li>5月初（5/7），95%。在黑屏幕上移动即可，不用考虑边界逻辑。熟悉使用的库。</li>
<li>5月中（5/12），90%。考虑小人在背景上移动产生的效果，考虑边界。</li>
<li>5月底（5/25），80%。要具有一定的可玩性。</li>
<li>6月初（6/5），90%。</li>
<li>与整个Game子项目同步进行。5月底（5/30），85%。</li>
</ol>


<h2>理想化时间预期</h2>

<ol>
<li>6月初（6/1），85%。</li>
<li>6月初（6/5），95%。</li>
<li>6月中（6/15），90%。</li>
<li>7月中（7/15），80%。</li>
<li>7月底（7/30），90%。</li>
<li>与整个子项目同步进行，8月中（8/15），99%。</li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/02/28/egui-event/">EGUI Event的新方法</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-02-28T02:31:00+08:00" pubdate data-updated="true">Feb 28<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>断了一下午的网，总算能上了。发现刷github pages用来积累commit很不错..</p>

<hr />

<p>EGUI的event模块利用Linux内核的evdev来获取用户输入。但是之前的方法需要确定出具体的鼠标和键盘，带来了一个很大的问题，因为有时候确定起来标准很模糊。比如在ArchLinux Host + VirtualBox + ArchLinux VM的话，鼠标设备有两个，但其中一个由于未知的原因无法获取点击事件，而且一旦从其中一个读取，另一个就不会再提供同样的消息。这样，即使想通过select所有的设备来检测鼠标也很困难。</p>

<p>Linux的evdev是一个统一的输入设备接口，不管是鼠标、键盘还是手柄，消息的格式都是一样的。所以一个很自然的方法就是直接从所有的event设备接收输入。这个想法也是经历过上述的问题才获得的，因为尽管有两个evdev对应同一个设备，一条消息也不会出现两次。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/02/24/rip-audio-cd-from-linux-cli/">Rip Audio CD</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-02-24T05:09:00+08:00" pubdate data-updated="true">Feb 24<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>买了CLICK和apple symphony之后是第一次在Linux命令行下Rip，因为想采用尽可能原始和准确的方法，所以稍微绕得有点复杂。</p>

<p>首先，使用的主要工具是cdrdao。用cdrdao的<code>read-cd</code>命令，可以得到一对bin/toc文件。bin是原始的音频数据，toc是相当于cue的东西，可以用toc2cue转换到cue。cdrdao的命令具体是：<code>cdrdao read-cd data.toc</code>。第二个参数是toc文件的名字，虽然需要指定这个文件名，但bin文件却可以缺省，不知道为什么。</p>

<p>之后是缓慢的读取过程。其实随时间增加好像有变快的趋势。</p>

<p>读取完之后，<code>file data.bin</code>会发现返回的文件类型是<code>data</code>，不可识别。因为它没有wav的文件头。实际上，这时用<code>aplay -f cdr</code>才可以播放，所以可以推测出这个文件是big endian的。我的习惯是要把CD切成单曲，所以接下来要用bchunk。bchunk有个参数<code>-s</code>可以交换字节序，所以这个时候就要用到它了，不然切出来就会变成杂音。具体指令是<code>bchunk -ws data.bin data.cue data-</code>。</p>

<p>切出来之后，连文件头也已经加好了，是WAV文件。所以接下来是<code>flac data-*.wav</code>。</p>

<p>如果不需要音轨信息，就可以结束了。但那显然不可能。用CD获取音轨信息最好的工具是Musicbrainz的官方工具picard。遗憾的是，这是一个图形化界面的工具。先导入所有的flac文件，然后查询CD信息，获取结束之后将flac一首首拖到CD的音轨信息上去，最后保存即可。</p>

<p>如果CD比较高级，自带有音轨信息，那么可以用cdda2wav来读取。<code>cdda2wav -J -g -D /dev/sr0</code>。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/02/23/opening-report-click/">开箱报告</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-02-23T23:07:00+08:00" pubdate data-updated="true">Feb 23<span>rd</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这次买了两张CD，ClariS的CLICK和竹達彩奈的apple symphony。快递比较坑，到了之后还延迟了三天才送货。不过很不幸，手一滑给了揽货员一个差评。晚上再补派货员的。</p>

<p>第一张照例是开箱。萌购的习惯就是拿报纸来填充，所以最上面一张总是报纸。</p>

<p><a href="http://www.flickr.com/photos/47575131@N06/12713437764/" title="IMG_20140223_125147 by Stone Kang, on Flickr"><img class="lazy" src="" data-src="https://farm8.staticflickr.com/7441/12713437764_5842e97423_c.jpg" width="800" height="600" alt="IMG_20140223_125147"></a></p>

<p>里面一层也和以往一样，是塑料的充气袋。</p>

<p><a href="http://www.flickr.com/photos/47575131@N06/12713439594/" title="IMG_20140223_125247 by Stone Kang, on Flickr"><img class="lazy" src="" data-src="https://farm6.staticflickr.com/5544/12713439594_609bf18a11_c.jpg" width="800" height="600" alt="IMG_20140223_125247"></a></p>

<p>萌购的可脱标签在两张CD上都有。</p>

<p><a href="http://www.flickr.com/photos/47575131@N06/12713440584/" title="IMG_20140223_125507 by Stone Kang, on Flickr"><img class="lazy" src="" data-src="https://farm8.staticflickr.com/7295/12713440584_63573cd8fb_c.jpg" width="800" height="600" alt="IMG_20140223_125507"></a></p>

<p><a href="http://www.flickr.com/photos/47575131@N06/12713441944/" title="IMG_20140223_125529 by Stone Kang, on Flickr"><img class="lazy" src="" data-src="https://farm4.staticflickr.com/3777/12713441944_14ff4584f8_c.jpg" width="800" height="600" alt="IMG_20140223_125529"></a></p>

<p>apple symphony的包装袋是只能破坏的，所以打开之后就没法再装回去了。不知道是不是跟通常盘有关。</p>

<p><a href="http://www.flickr.com/photos/47575131@N06/12712991465/" title="IMG_20140223_125629 by Stone Kang, on Flickr"><img class="lazy" src="" data-src="https://farm4.staticflickr.com/3751/12712991465_2cf95715e3_c.jpg" width="800" height="600" alt="IMG_20140223_125629"></a></p>

<p>CLICK是期间限定生产盘，14年5月末截止。袋子上有CD的标签，看来这个袋子不是萌购套上的，应该是买来就有。袋子是封条式的，可以重复使用。但由于是单曲，所以CD盒是纸盒（CD托盘当然还是塑料），而且歌词只有一张纸。这是头一次买单曲CD。</p>

<p><a href="http://www.flickr.com/photos/47575131@N06/12712992125/" title="IMG_20140223_125646 by Stone Kang, on Flickr"><img class="lazy" src="" data-src="https://farm8.staticflickr.com/7314/12712992125_917596bfd6_c.jpg" width="800" height="600" alt="IMG_20140223_125646"></a></p>

<p>apple symphony毕竟是album，尽管是通常盘，还是比较正式一些，有厚厚的一册歌词，跟其他专辑一样。apple symphony还有一种特别版，非常贵，但是当然特典也很多。这次还是望而却步了。</p>

<p><a href="http://www.flickr.com/photos/47575131@N06/12712992685/" title="IMG_20140223_130053 by Stone Kang, on Flickr"><img class="lazy" src="" data-src="https://farm6.staticflickr.com/5539/12712992685_740b523961_c.jpg" width="800" height="600" alt="IMG_20140223_130053"></a></p>

<p><a href="http://www.flickr.com/photos/47575131@N06/12713158703/" title="IMG_20140223_130101 by Stone Kang, on Flickr"><img class="lazy" src="" data-src="https://farm6.staticflickr.com/5523/12713158703_af32635672_c.jpg" width="800" height="600" alt="IMG_20140223_130101"></a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/02/23/event-listener/">Event Listener</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-02-23T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><!DOCTYPE html>

<html>
<head>
  <title>event_listener.c</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="css/docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>event_listener.c</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>这个函数除了作为主循环存在以外，还包含了很多其他的机能，涉及到诸如fdset之类的概念。但为了简单一点介绍主循环本身，这里就略过细节，只说一下大体的结构。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">extern</span> si_t event_listener_exec(<span class="hljs-keyword">struct</span> event_listener *l)
{</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>while(1)是典型的无限循环，当然它还是会有出口的，内部的某个地方肯定有break、return或者exit()之类的东西。
主循环一般都可以写成无限循环。不过如果做过ACM的话，应该会知道，他们的主循环一般是写成while(scanf()!=EOF)的。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>首先是一些初始化的步骤。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        si_t select_ret = <span class="hljs-number">0</span>;
        si_t maxfd = <span class="hljs-number">0</span>;

        maxfd = reload_fd_set(l);

        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == maxfd) {
            EGUI_PRINT_INFO
                (<span class="hljs-string">"event_listener listener set is empty; quit waiting."</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>select是一个跟IO有关的系统调用，等待文件描述符的输入输出事件。当它返回的时候，就说明有内容需要读或者可以写入了。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        select_ret = select(maxfd, &amp;l-&gt;read_set, &amp;l-&gt;write_set, NULL, NULL);
        <span class="hljs-keyword">if</span> (l-&gt;callback &amp;&amp; l-&gt;callback() &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">continue</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>如果select返回的结果大于0，说明没有出错，确实可以进行读写。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (select_ret &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">struct</span> list_node *n = NULL;</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>循环所有的监听内容。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">for</span> (n = l-&gt;event_handler_set.node.next;
                 n != &amp;l-&gt;event_handler_set.node; n = n-&gt;next) {
                <span class="hljs-keyword">struct</span> events_handler *e = (<span class="hljs-keyword">struct</span> events_handler *)(n-&gt;data);
                <span class="hljs-keyword">if</span> ((SELECTER_EVENT_TYPE_READ == e-&gt;event_type
                     &amp;&amp; FD_ISSET(e-&gt;uds.sock_fd, &amp;l-&gt;read_set))
                    || (SELECTER_EVENT_TYPE_WRITE == e-&gt;event_type
                        &amp;&amp; FD_ISSET(e-&gt;uds.sock_fd, &amp;l-&gt;write_set))) {
                    <span class="hljs-keyword">int</span> handler_ret = <span class="hljs-number">0</span>;

                    <span class="hljs-keyword">if</span> (is_socket_closed(&amp;e-&gt;uds)) {
                        n = del_handler_while_loop(l, n);
                        <span class="hljs-keyword">continue</span>;
                    }

                    <span class="hljs-keyword">if</span> (NULL == e-&gt;handler) {
                        <span class="hljs-keyword">continue</span>;
                    }</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>终于，一切确认工作都做完之后，就到了处理的过程。handler是一个函数指针成员，指向负责处理这个监听类型的函数，也就是说监听的不同内容有不同的处理函数。在这个处理函数里，有些模块会进行读取，有些会与客户端建立连接（建立连接也是IO操作的一种，select也会返回）。
需要注意的是，这是在for循环里面，也就是说这只是一个方面的监听。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    handler_ret = e-&gt;handler(&amp;e-&gt;uds, e-&gt;arg);</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>handler_ret是处理函数返回的结果，通过这个返回结果，处理函数可以控制主循环的流程，比如继续监听、中止这个部分的监听、或者中止整个主循环（也就是退出服务器）。这个switch就是用来判断应该怎样继续的。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="hljs-keyword">switch</span> (handler_ret) {
                    <span class="hljs-keyword">case</span> SELECTER_RETURN_TYPE_CONTINUE:
                        <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> SELECTER_RETURN_TYPE_REMOVE_HANDLER:
                        n = del_handler_while_loop(l, n);
                        <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> SELECTER_RETURN_TYPE_END:
                        <span class="hljs-keyword">for</span> (n = l-&gt;event_handler_set.node.next;
                             n != &amp;l-&gt;event_handler_set.node; n = n-&gt;next) {
                            <span class="hljs-keyword">struct</span> events_handler *e =
                                (<span class="hljs-keyword">struct</span> events_handler *)(n-&gt;data);
                            event_handler_exit(e);
                        }
                        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
                    <span class="hljs-keyword">default</span>:
                        EGUI_PRINT_ERROR
                            (<span class="hljs-string">"event handler return unknown type: %d"</span>,
                             handler_ret);
                        <span class="hljs-keyword">break</span>;
                    }
                }
            }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>这是判断select返回结果的那个if。如果select返回的结果小于0，说明什么地方出错了。我们的服务器在这时就不做任何判断，直接退出。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (select_ret &lt; <span class="hljs-number">0</span>) {
            EGUI_PRINT_SYS_ERROR
                (<span class="hljs-string">"Failed to get select result in selector: select()"</span>);
            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/02/22/flip/">Flip</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-02-22T20:52:00+08:00" pubdate data-updated="true">Feb 22<span>nd</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><link rel="stylesheet" href="css/flip.css"></p>

<p>Flip game是一个小游戏，在二维棋盘上点击任意方格，其相邻方格都会跟它一起改变颜色。游戏目标是将所有方格由白色变成黑色。</p>

<p>在下面的表格中输入长和宽，点击按钮开始。</p>

<p><input type="text" id="row">
<input type="text" id="col">
<button id="start">Start</button></p>

<div id="gameArea" align="center"></div>


<script src="js/vendor/jquery.min.js"></script>


<script src="js/vendor/underscore-min.js"></script>


<script src="js/vendor/backbone-min.js"></script>


<script src="js/flip.bb.js"></script>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/02/22/object-tree/">Object Tree</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-02-22T05:02:00+08:00" pubdate data-updated="true">Feb 22<span>nd</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>EGUI的对象树</h1>

<p>对象树就是在object结构中组建出树。组建树的代码在object.c中并没有提供，而是在其他地方隐式体现的。</p>

<h1>对象树的隐式规则</h1>

<p>对象本身并没有强制組成一棵树，也就是说并不是一个object结构体就能组成一棵单结点的树。</p>

<p>一棵对象树必须要有至少两个结点，这两个结点都是树根。它们可以理解成一种循环的上下关系。令真正的树根为root，那么它上面必须还有一个伪根fakeroot，并且<code>root-&gt;parent==fakeroot &amp;&amp; fakeroot-&gt;parent==root</code>，也就是两个结点互相为对方的父结点。</p>

<p>在添加更多子结点的时候，<code>object_attach_child()</code>的参数应该是root及其下面的结点。</p>

<p>由于并没有规定谁是真正的树根，在编写API的时候，可以选择返回任意一个树根，但是在用object.c提供的接口进行遍历的时候，应该认定<strong>fakeroot</strong>为树根。</p>

<p>object.c提供的遍历接口依赖于root和fakeroot的这种循环上下关系，而且<code>attach_child</code>也会及时地修正fakeroot里保存的内部数据，所以在使用这些接口时需要考虑清楚fakeroot的安全性（它是不是还被用做保存了其他数据，因为那些数据在<code>attach_child</code>的时候会被覆盖）和正确性（循环上下关系是否成立）。</p>

<h1>代码示例</h1>

<p>以下代码摘自<code>application/manipulate_window.c</code>。</p>

<div>
  <pre><code class='cpp'>node = OBJECT_POINTER(w);
tree = node-&gt;parent;
tree_real_parent = tree-&gt;parent;
tree-&gt;parent = node;
node = object_tree_l_most_node(tree);
while(node != NULL)
{
    union message msg;
    msg.base.type = MESSAGE_TYPE_WIDGET_REPAINT;
    msg.widget_repaint.area = WIDGET_POINTER(node)-&gt;area;
    if(WIDGET_POINTER(node)-&gt;callback != NULL)
        WIDGET_POINTER(node)-&gt;callback(node, &amp;msg);

    node = object_tree_iterator_increment(tree, node);
}
tree-&gt;parent = tree_real_parent;</code></pre>
</div>


<p>这段代码是为了遍历以w（也就是node）为根的子树。由于在原树中w并不是树根，所以需要临时把它的父结点改成fakeroot来让w成为树根，遍历完再改回去。代码上体现在第3行和第16行。</p>

<p>在第14行增长迭代器的时候，提供给接口的参数是作为fakeroot存在的tree指针，而不是真正的根。实际上，由于真正的根在初始化部分之后基本上就没用了，所以在这段代码后半部分直接就把node当迭代器来用了。（<strong>这是很不好的习惯！</strong>）</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/02/17/guess/">Guess</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-02-17T00:00:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


  <div class="entry-content"><!DOCTYPE html>

<html>
<head>
  <title>guess.c</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="css/docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>guess.c</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-preprocessor">#include &lt;stdlib.h&gt;</span>

<span class="hljs-preprocessor">#include "application.h"</span>
<span class="hljs-preprocessor">#include "geometry.h"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>intv是在窗口布局的时候控件之间的空隙大小。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">const</span> ui_t intv = <span class="hljs-number">5</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>窗口和控件的指针，为了方便在submit_callback()函数里访问而定义为全局变量。实际上应该有更好的方法来避免全局变量。
这些都只是空指针，空间的分配在主函数里进行。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> window *w = NULL;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> button *submit = NULL;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> label *result = NULL;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> text_line *input = NULL;</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>开始猜数时随机产生一个数放在answer变量里。没有初始化的时候最好赋一个不可能的值，表示尚未初始化。随机数都大于等于0，所以-1是一个比较好的“不可能值”。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> answer = -<span class="hljs-number">1</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>用户点击submit按钮之后，程序会自动调用这个函数。因为在主函数里替换掉了button控件原来的callback函数指针。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">static</span> si_t submit_callback(<span class="hljs-keyword">void</span> *self, <span class="hljs-keyword">void</span> *msg)
{</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>先调用button控件原始的callback函数，以防我们自己的处理函数漏掉了什么内部过程。实际上这样实现是有问题的，因为不管怎样都应该先进行内部过程再执行用户的代码。现在这样实现的button控件就给用户留下了跳过内部过程的机会。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    button_default_callback(self, msg);</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>MESSAGE_TYPE_MOUSE_SINGLE_CLICK是鼠标单击的事件。说个题外话，这是在服务器端处理过的结果，服务器端产生这个事件的条件是先鼠标按下（MESSAGE_TYPE_MOUSE_PRESS），再松开（MESSAGE_TYPE_MOUSE_RELEASE）。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (message_get_type(msg) == MESSAGE_TYPE_MOUSE_SINGLE_CLICK) {</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>text_line_get_buf函数获取用户输入的内容，然后用stdlib.h里的atoi函数将这个字符串转换成整数。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">int</span> num = atoi(text_line_get_buf(input));</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>如果answer尚未初始化，就产生一个新的随机数作为这一轮的答案。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span>(answer == -<span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>随机数的范围限定在100以内，也就是[0,100)。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            answer = rand()%<span class="hljs-number">100</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>如果这次猜的数正好就是答案，那么游戏结束，并清空答案，以便下一次重新生成一个随机数。如果不正确，那么按大小给出提示。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span>(num==answer) {
            result-&gt;text = <span class="hljs-string">"Right! Next time will start again."</span>;
            answer = -<span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num&gt;answer) {
            result-&gt;text = <span class="hljs-string">"Too big"</span>;
        } <span class="hljs-keyword">else</span> {
            result-&gt;text = <span class="hljs-string">"Too small"</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>因为前面修改了result控件的内容，所以这里需要重新绘制一次，让新的内容显示出来。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        label_repaint(result);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-keyword">int</span> main()
{</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>应用程序初始化所需的几个常量。基本上所有用户程序都是这样。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    si_t video = VIDEO_ACCESS_MODE_BUFFER;
    si_t app = APPLICATION_TYPE_NORMAL;</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>随机数初始化。每次程序开始执行的时候，用当前的时间作为随即种子。没有这个的话，每次重新执行程序都会产生一样的答案。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    srand(time(NULL));

    application_init(video, app, <span class="hljs-string">"Number Guessing"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>窗口初始化（分配窗口控件）。参数是窗口标题。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    w = window_init(<span class="hljs-string">"Number Guessing"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>如果初始化不成功，可能是服务器有故障或者没有启动。那么我们也退出。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!w) {
        application_exit();
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>窗口的大小和位置。这个公式会让窗口定位在屏幕中央。get_screen_width获取屏幕的宽度。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    window_set_bounds(w, (get_screen_width() - <span class="hljs-number">500</span>) / <span class="hljs-number">2</span>,
                      (get_screen_height() - <span class="hljs-number">400</span>) / <span class="hljs-number">2</span>, <span class="hljs-number">500</span>, <span class="hljs-number">400</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>分配一个文本框。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    input = text_line_init(<span class="hljs-number">100</span>, <span class="hljs-number">0</span>);
    text_line_set_bounds(input, intv, intv, <span class="hljs-number">400</span>, <span class="hljs-number">30</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>分配一个按钮，按钮上面的文字是”Submit”。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    submit = button_init(<span class="hljs-string">"Submit"</span>);
    button_set_bounds(submit,
                      input-&gt;area.x + input-&gt;area.width + intv,
                      input-&gt;area.y,
                      w-&gt;area.width - (input-&gt;area.x + input-&gt;area.width +
                                       intv) - intv, input-&gt;area.height);</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>分配一个文本标签，用来显示提示信息。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    result = label_init(<span class="hljs-string">"Please input a number and press Submit"</span>);
    label_set_bounds(result,
                     input-&gt;area.x,
                     input-&gt;area.y + input-&gt;area.height + intv,
                     submit-&gt;area.x + submit-&gt;area.width - intv,
                     input-&gt;area.height);</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>替换掉按钮的callback函数，让按钮被按下时执行我们自己的函数，而不是控件内部的函数。（当然我们自己的函数还需要再调用那个内部处理函数，像前面写的那样。）</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    submit-&gt;callback = submit_callback;</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>将申请的几个控件附加到窗口上。只有这样才能让它们显示出来。（没有窗口的屏幕上怎么会出现控件？）</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    object_attach_child(OBJECT_POINTER(w), OBJECT_POINTER(submit));
    object_attach_child(OBJECT_POINTER(w), OBJECT_POINTER(result));
    object_attach_child(OBJECT_POINTER(w), OBJECT_POINTER(input));</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>将窗口添加到本应用程序中。这也是一个例行过程，所有程序都这么干。其实这后面到底做了什么我也不记得了。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    application_add_window(NULL, w);</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>设置主窗口。如果有多个窗口，那么当主窗口关闭的时候，其他窗口也会自动关闭，应用程序会自动退出。如果只有一个窗口，那么其实设不设置都没有区别。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    application_set_main_window(w);</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>开始执行主循环。这个函数不会很快返回，我们的程序会在这里等待用户输入，并在有输入的时候自动跳转到之前设置的callback函数里去处理。直到用户关闭所有的窗口，这个函数才会返回。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    application_exec();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/02/16/curry/">Curry首页脚本</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-02-16T21:13:00+08:00" pubdate data-updated="true">Feb 16<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><canvas id='curry-game'></canvas></p>

<script src='js/curry.js'></script>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/02/15/itemlist/">Item List App</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-02-15T01:33:00+08:00" pubdate data-updated="true">Feb 15<span>th</span>, 2014</time>
        
      </p>
    
  </header>


  <div class="entry-content"><div id='friend_list'></div>


<p><button id='add_friend'>Add friend</button></p>

<script src="js/vendor/jquery.min.js"></script>


<script src="js/vendor/underscore-min.js"></script>


<script src="js/vendor/backbone-min.js"></script>


<script src='js/itemlist.js'></script>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/3/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/03/15/jekyll-and-bootstrap/">Jekyll + Bootstrap</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/03/08/mono/">Linux + Mono + WinForm == Windows + VC# ?</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/03/05/egui-client-message-dispatching/">Egui Client Message Dispatching</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/03/05/egui-button-callback/">Egui Button Callback</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/03/04/egui-modules/">EGUI模块结构</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Your Name -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
